

## 一、线程停止

#### 1. 有如下几种方式使线程停止执行： 
（1）共享bool类型变量方式； 

（2）调用线程interrupt方式，同时通过isInterrupted方式判断线程是否被停止，若停止则终止循环操作（线程类中循环外没有其他操作）； 

（3）调用线程interrupt方式 ＋ 抛出异常方式（循环外有其他操作情况）； 

（4）调用线程interrupt方式 ＋ return方式（循环外有其他操作情况）； 

（5）将线程设置为守护线程，则所有非守护线程停止时，守护线程便结束； 

[Thread之十：停止线程方法汇总](https://www.cnblogs.com/duanxz/p/3712734.html) 

[interrupt、interrupted和isInterrupted的区别](https://blog.csdn.net/hj7jay/article/details/53462553)

建议使用抛出异常的方式：异常可上抛




#### 2、 暂停线程

1. suspend()暂停线程
2. resume()恢复线程


**缺点**：容易造成公共的同步对象的独占， 使其他对象无法访问公共同步对象。


 看下面案例
```
public class FirstDemo {
	public static void main(String[] args) {
		try {
			MyThread tt = new MyThread();
			tt.start();
			Thread.sleep(2000);
			tt.suspend();
			System.out.println("main end");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

	}
}
```

```
public class MyThread extends Thread {
	private long i = 0;

	public void run() {
		while (true) {
			i++;
			//System.out.println(i++); 
		}
	}
}
```
如果注释掉上面输出这行，控制台会有main end输出，但是取消注释，输出到一定数字就不动了。

![TIM截图20180808102949](https://note.youdao.com/yws/res/38518/27B0618821484E07A147B5FE57B4C5E0)

为什么？

原因是，println()方法是同步的，当线程进入println()方法时获得了同步锁，而此时挂起线程导致同步锁不被释放，所以主线程的println()方法不会执行。这就是独占特性。

println()源代码：
```
    public void println(long x) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }
```

另外，在使用suspend和resume方法也容易出现因为线程的暂停导致数据不一致的情况。

#### 3、yield方法
yield()方法的作用：放弃当前的cpu资源，将它让给其他任务去占用cpu执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得cpu时间片。

先了解一下线程优先级，线程总是存在优先级，优先级范围在1~10之间。

JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。

线程的优先级具有继承性。

高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部先执行完。

优先级高的线程不是每一次都先执行完。优先级具有随机性。

设置优先级setPriority()方法的源码：
```
    public final void setPriority(int newPriority) {
        ThreadGroup g;
        checkAccess();
        if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
            throw new IllegalArgumentException();
        }
        if((g = getThreadGroup()) != null) {
            if (newPriority > g.getMaxPriority()) {
                newPriority = g.getMaxPriority();
            }
            setPriority0(priority = newPriority);
        }
    }
```
yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 

结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。

#### 4、join方法
Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。例如：

```
Thread t = new MyThread();
        t.start();
        t.join(); 
```
另外，join()方法还有带超时限制的重载版本。 例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。 

线程的加入join()对线程栈导致的结果是线程栈发生了变化，当然这些变化都是瞬时的。下面给示意图： 

![TIM截图20180808113328](https://note.youdao.com/yws/res/38523/837C4CC66C31446ABCBB9E7F04EA4604)

**小结**：线程离开运行状态的几种方法： 

1、调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。 

2、调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。 

3、调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。



除了以上三种方式外，还有下面几种特殊情况可能使线程离开运行状态： 

1、线程的run()方法完成。 

2、在对象上调用wait()方法（不是在线程上调用）。 

3、线程不能在对象上获得锁定，它正试图运行该对象的方法代码。 

4、线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。

#### 5、守护线程
java的线程分为两种：User Thread(用户线程)、DaemonThread(守护线程)。

只要当前JVM实例中尚存任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作，Daemon作用是为其他线程提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)，他就是一个很称职的守护者。

## 二、对象及变量的并发访问
### 1、synchronized同步方法

#### 1.1. 方法内的变量为线程安全

**方法中的变量**不存在线程安全问题，永远都是线程安全的。这是方法内部的变量是私有的特性造成的。

#### 1.2. 实例变量非线程安全

1. 多个线程访问一个**对象的实例变量**，则可能出现“脏读”（非线程安全）。

2. 多个线程访问一个不同步的方法时，则可能出现“脏读”（非线程安全）。

在方法前，加入synchronized之后即可同步。

#### 1.3. 多个对象多个锁
看下面代码：

```
public class HasSelfPrivateNum {  
    private int num = 0;  
    synchronized public void addI(String username) {  
        try {  
            if (username.equals("a")) {  
                num = 100;  
                System.out.println("a set over!");  
                Thread.sleep(2000);  
            } else {  
                num = 200;  
                System.out.println("b set over!");  
            }  
            System.out.println(username + " num=" + num);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
} 
```
 ![TIM截图20180810151543](https://note.youdao.com/yws/res/38514/466B989772CB4A66A26ECFA378611BE0)

运行：
```
public class Run {  
    public static void main(String[] args) {  
        HasSelfPrivateNum numRef1 = new HasSelfPrivateNum();  
        HasSelfPrivateNum numRef2 = new HasSelfPrivateNum();  
        ThreadA athread = new ThreadA(numRef1);  
        athread.start();  
        ThreadB bthread = new ThreadB(numRef2);  
        bthread.start();  
    }  
} 
```
运行结果：

![TIM截图20180810151937](https://note.youdao.com/yws/res/38524/B2F6DEF6DA7645EFB492168A9704549B)

问题：从上面程序运行结果来看，虽然在HasSelfPrivateNum.java中使用了synchronized关键字，但打印的顺序却不是同步的，是交叉的。为什么是这样的结果呢？

关键字synchronized取得的锁都是对象锁，而不是把一段代码或方法（函数）当作锁，所以在上面的示例中，哪个线程先执行带synchronized关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能呈等待状态，前提是多个线程访问的是同一个对象。

但如果多个线程访问多个对象，则JVM会创建多个锁。上面的示例就是创建了2个HasSelfPrivateNum.java类的对象，所以就会产生出2个锁。

同步的单词为synchronized，异步的单词为asynchronized。

#### 1.4. synchronized方法与锁对象

上面这个案例，如果在类Run的main方法里只创建一个对象，  

如果HasSelfPrivateNum的方法加synchronized，A线程先持有object对象的Lock锁，B线程如果在这时调用object对象中的synchronized类型的方法则需等待，也就是同步。

#### 1.5. 脏读

虽然在赋值时进行了同步，但在取值时有可能出现一些意想不到的意外，这种情况就是脏读（dirtyRead）。发生脏读的情况是在读取实例变量时，此值已经被其他线程更改过了。

> 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法锁，更准确地讲，是获得了对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以随意调用其他的非synchronized同步方法。

> 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法所在对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，而B线程如果调用声明了synchronized关键字的非X方法时，必须等A线程将X方法执行完，也就是释放对象锁后才可以调用。这时A线程已经执行了一个完整的任务，也就是说username和password这两个实例变量已经同时被赋值，不存在脏读的基本环境。

脏读一定会出现操作实例变量的情况下，这就是不同线程“争抢”实例变量的结果。

#### 1.6. synchronized锁重入

关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。这也证明**在一个synchronized方法/块的内部调用本类的其他synchronized方法/块时**，是永远可以得到锁的。

可重入锁也支持在父子类继承的环境中。存在父子类继承关系时，子类是完全可以通过“可重入锁”**调用**父类的同步方法的。

#### 1.7. 出现异常时，锁自动释放

#### 1.8. 同步不具有继承性
同步不能继承，所以还得在子类的方法中添加synchronized关键字

### 2、synchronized同步语句块

用关键字synchronized声明方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个长时间的任务，那么B线
程则必须等待比较长时间。在这样的情况下可以使用synchronized同步语句块来解决。

不在synchronized块中就是异步执行，在synchronized块中就是同步执行。

同步synchronized(this)代码块是锁定当前对象的

多个线程调用同一个对象中的不同名称的synchronized同步方法或synchronized(this)同步代码块时，调用的效果就是按顺序执行，也就是同步的，阻塞的。

 Java还支持对“任意对象”作为“对象监视器”来实现同步的功能。</br>
这个“任意对象”大多数是实例变量及方法的参数，使用synchronized(非this对象)格式的作用只有1种：

synchronized(非this对象x)同步代码块。

“synchronized(非this对象x)”格式的写法是将x对象本身作为“对象监视器”：
> 当多个线程同时执行synchronized(x){}同步代码块时呈同步结果。

> 当其他线程执行**x对象中synchronized同步方法**时呈同步效果。

> 当其他线程执行**x对象方法里面的synchronized(this)代码块**时也呈现同步效果。

需要注意的是：如果其他线程调用不加synchronized关键字的方法时，还是异步调用。

#### 2.1. 静态同步synchronized方法与synchronized(类名.class)语句块

> **关键字synchronized加在static静态方法上，是给当前*.java文件对应的Class类上锁；而加在非static静态方法上，是给对象上锁**。

synchronized关键字加static静态方法和synchronized加到非static方法上的区别：一个锁的是class类，一个锁的是当前的对象。

同步synchronized（class）代码块的作用和synchronized static方法作用一样。

#### 2.2. String的常量池特性

在JVM中具有常量池缓存功能,例如： 
```
public static void main(String[] args) {
       String s1 = "hello";
       String s2 = "hello";
       String s3 = "he" + "llo";
       String s4 = "hel" + new String("lo");
       String s5 = new String("hello");
       String s6 = s5.intern();
       String s7 = "h";
       String s8 = "ello";
       String s9 = s7 + s8;
        //在jdk1.6,1.7,1.8下运行的结果为：
        System.out.println(s1==s2);//true
        System.out.println(s1==s3);//true
        System.out.println(s1==s4);//false
        System.out.println(s4==s5);//false
        System.out.println(s1==s6);//true
        System.out.println(s1==s9);//false
       
    }
```
 将synchronized(string)同步块与string联合使用时，要注意常量池带来的一些意外：
 例如：
```
public class Service {
    public static void print(String parm) throws InterruptedException{
        synchronized (parm) {
            while(true){
                System.out.println("线程名："+Thread.currentThread().getName());
                Thread.sleep(1000);
            }
        }
    }

    public static void main(String[] args) {
        Service s=new Service();
        ThreadA a=new ThreadA(s);
        a.setName("A");
        a.start();
        ThreadB b=new ThreadB(s);
        b.setName("B");
        b.start();
    }
}
```
![TIM截图20181008181037](https://note.youdao.com/yws/res/38513/944B162A5B4645ACA8280EA9DCB2A244)

运行结果表明一直运行的A线程，这是因为两个线程传入的string值都是AAAA，两个线程持有相同的锁，导致线程B不能执行。这就是string常量池导致的问题，因此大多数情况下，同步synchronized代码块都不使用String作为锁对象，而改用其他，比如new Object()实例化一个Object对象，但它并不放入缓存中。

#### 2.3. 同步synchronized方法无限等待与解决 
例如：
```
public class Service {
  synchronized  public void methodA(){
      System.out.println("methodA begin");
      boolean isContinueRun = true;
      while (isContinueRun) {

      }
      System.out.println("methodA end");
  }

  synchronized  public void methodB(){
      System.out.println("methodB begin");
      System.out.println("methodB end");
  }
}
```
![TIM截图20181008181411](https://note.youdao.com/yws/res/38517/1208C20969534BE0928664AF79750637)
```
public class Test {
    public static void main(String[] args) {
        Service service = new Service();
        ThreadA threadA = new ThreadA(service);
        threadA.setName("a");
        threadA.start();
        ThreadB threadB = new ThreadB(service);
        threadB.setName("b");
        threadB.start();
    }
}
```
运行结果:b线程一直得不到运行。

当一个类中，有两个synchronized方法，其中一个方法是一个死循环，当多个线程调用类中的不同方法时，会造成死锁。

解决方法是把synchronized方法转换成在方法中加synchronized语句块，而且两个方法持有不同的对象，这就解决了死锁问题，当多个线程调用不同方法时，虽然一个线程出现死锁，但不影响其他应用调用另一个方法。
改成：
```
public class Service {
    Object object1 = new Object();
    public void methodA(){
        synchronized (object1) {
            System.out.println("methodA begin");
            boolean isContinueRun = true;
            while (isContinueRun) {

            }
            System.out.println("methodA end");
        }
  }
    Object object2 = new Object();
    public void methodB(){
        synchronized (object2) {
            System.out.println("methodB begin");
            System.out.println("methodB end");
        }
  }
}
```

#### 2.4. 多线程的死锁

java死锁是因为不同的线程都在等待根本不可能释放的锁，从而导致所有任务都无法继续完成。
```
public class DeadThread implements  Runnable{
    public String username;
    public Object object1 = new Object();
    public Object object2 = new Object();
    public void setFlag(String username) {
        this.username = username;
    }
    @Override
    public void run() {
        if (username.equals("a")) {
            synchronized (object1) {
                try {
                    System.out.println("username="+username);
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                synchronized (object2) {
                    System.out.println("按lock1-》lock2代码顺序执行了");
                }
            }
        }

        if (username.equals("b")) {
            synchronized (object2) {
                try {
                    System.out.println("username="+username);
                    Thread.sleep(2000);

                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                synchronized (object1) {
                    System.out.println("按lock2-》lock1代码顺序执行了");
                }
            }
        }

    }
}
```

```
public class Run {
    public static void main(String[] args) {
        try {
            DeadThread t1 = new DeadThread();
            t1.setFlag("a");
            Thread thread1 = new Thread(t1);
            thread1.start();
            Thread.sleep(100);
            t1.setFlag("b");
            Thread t2 = new Thread(t1);
            t2.start();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


    }
}
```
运行结果：
```
username=a
username=b
```
可以用jdk自带的工具来监测是否有死锁现象。进入cmd,在进入jdk安装的bin目录，执行jps命令：
![TIM截图20180816164821](https://note.youdao.com/yws/res/38525/B215DC82893B42B0825E692AF5CFC997)

得到运行的线程Run的id值是7076，再执行jstack命令，查看结果：

![TIM截图20180816165114](https://note.youdao.com/yws/res/38522/6143297FCB8849FCB0B97D1422AB2435)

监测出现死锁。

死锁是程序设计的bug,在程序设计时就要避免双方互相持有对方锁的情况，需要说明的是，本实验使用synchronized嵌套的代码结构来实现死锁，

其实不用嵌套的synchronized代码结构也会出现死锁，与是否嵌套无任何关系，不要被代码结构所误导，只要互相等待双方释放就有可能出现死锁。


 ### 3、 volatile关键字

 volatile关键字的主要作用使变量在多个线程间可见。

####  3.1. 关键字volatile与死循环 

例如： 想通过改变flag的值，从而停止对service的test()方法，进行停止。

```
public class Test1 {
	public static void main(String[] args) {
		Service service = new Service();
		service.test();
		System.out.println("我要停止他。。。。");
		service.setFlag(false);
	}
}
class Service{
	private boolean flag = true;
	public boolean isFlag() {
		return flag;
	}
	public void setFlag(boolean flag) {
		this.flag = flag;
	}
	public void test(){
		while(flag){
			System.out.println("run test threadName="+Thread.currentThread().getName());
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
```
由于test()方法尚未执行完成，所以主线程（main）不会执行后续代码。如果想要解决，当然是用多线程技术了。

#### 3.2  解决同步死循环

```
public class Test2 {
	public static void main(String[] args) {
		final Service2 s2 = new Service2();
		Thread thread = new Thread(new  Runnable() {
			public void run() {
				s2.test();
			}
		},"service2");
		thread.start();
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("我要停止他。。。。");
		s2.setFlag(false);
	}
}
class Service2{
	private volatile boolean flag = true;
 
	public boolean isFlag() {
		return flag;
	}
 
	public void setFlag(boolean flag) {
		this.flag = flag;
	}
	public void test(){
		while(flag){
			System.out.println("run test threadName="+Thread.currentThread().getName());
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
```

注意：**如果没有添加volatile，那么同样的程序运行在JVM为-server服务器的环境中，会出现死锁**。内存结构如图：

![TIM截图20180821151811](https://note.youdao.com/yws/res/38520/F424E6066644489FB3BBAA5EC69E669D)

原因：

1、-server模式为了线程运行的效率，线程一直在私有堆栈中取得的flag的值为true，而main中设置的flag=false，更新的却是公共堆栈中的flag值。

2、而volatile的作用就是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。

3、总而言之，就是由于私有堆栈中的值和公共堆栈的值不同步造成的。

添加volatile修饰以后，内存结构如图：

![TIM截图20180821152036](https://note.youdao.com/yws/res/38516/B3D22BD264EC4322B0FEE2B110A170C8)

#### 3.3 volatile与synchronized的比较

使用volatile关键字，增加了实例变量在多个线程之间的可见性，但volatile关键字最致命的缺点是**不支持原子性**。

1、关键字volatile是线程同步的轻量级表现，所以volatile的性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。

2、多线程访问volatile不会发生阻塞，而synchronized会出现阻塞

3、volatile能保证数据的可见性，但是不能保证原子性。而synchronized可以保证原子性，也可以间接保证可见性，以为它会将私有内存和公共内存的数据作同步。

4、关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。

 

#### 3.4 volatile非原子的特性

volatile关键字只具有可见性，没有原子性，要实现原子性建议使用atomic类的系列对象，支持原子性操作（注意atomic类只保证本身方法的原子性，并不保证多次操作的原子性） 
```
public class VolatileNoAtomic extends Thread{
	private static volatile int count;
	//private static AtomicInteger count = new AtomicInteger(0);
	/*synchronized*/
	private  static void addCount(){
		for (int i = 0; i < 1000; i++) {
			count++ ;
			//count.incrementAndGet();
		}
		System.out.println(count);
	}
	public void run(){
		addCount();
	}
	
	/*10个线程对一个count变量进行++操作*/
	public static void main(String[] args) {
		VolatileNoAtomic[] arr = new VolatileNoAtomic[100];
		for (int i = 0; i < 10; i++) {
			arr[i] = new VolatileNoAtomic();
		}
		for (int i = 0; i < 10; i++) {
			arr[i].start();
		}
	}
	
}
```
代码最终输出结果应为10000，但实际输出结果如下。

![TIM截图20180821154159](https://note.youdao.com/yws/res/38521/A4BF64D7BE5641B0A65D63ADBC12FA8F)

可以使用AtomicINTEGER原子性进行实现，原子操作是不能分割的整体，没有其他线程能够中断或检查正在原子操作中的变量。一个原子类型就是一个原子操作可用的类型，它可以在没有锁的情况下做到线程安全（thread-saft）。将private static volatile int count;换成private static AtomicInteger count = new AtomicInteger(0)。将count++换成count.incrementAndGet();

 最终输出结果为10000.但并不是每次操作都能保证原子性。在addCount方法前加synchronized关键字。

 总结：

 如果想修改实例变量中的数据，比如i++，也就是i=i+1，则这样的操作其实并不是一个原子操作，也就是非线程安全的。表达式i++的操作步骤分解如下：

- ①从内存中取出i的值；
- ②计算i的值
- ③将i的值写到内存中

假如在第2步计算值的时候，另一个线程也修改i的值，那么这个时候就会出现脏数据。解决的办法其实就是使用synchronized关键字，volatile本身并不处理数据的原子性，而是强制对数据的读写及时影响到主内存中。

变量在内存中的工作过程：

(1)read 和load 阶段：从主存内存复制变量到当前线程工作内存；

(2)use和assign阶段:执行代码，改变共享变量值；

(3)store和write阶段：用工作内存数据，刷新主存对应变量的值

![TIM截图20180821154708](https://note.youdao.com/yws/res/38515/14906E6FF2E14F8E971715BEE6C85362)

3.5 synchronized代码块有volatile同步的功能 

关键字synchronized可以使多个线程访问同一个资源具有同步性，而且他还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能。
例如：

```
public class Service {
    private boolean isContinueRun = true;
    public void runMethod() {
        while(isContinueRun == true) {
        }
        System.out.println("停下来了");
    }
    public void stopMethod() {
        isContinueRun = false;
    }
}
```
![TIM截图20180821162542](https://note.youdao.com/yws/res/38512/814307F3E8C64D0183906913D4452479)

```
public class Run {
    public static void main(String[] args) {
        try {
            Service service = new Service();
            ThreadA threadA = new ThreadA(service);
            threadA.start();
            Thread.sleep(2000);
            ThreadB threadB = new ThreadB(service);
            threadB.start();
            System.out.println("已经发起停止的命令");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}
```
已经发起停止的命令，以-server服务器模式运行得到死循环

得到上面结果的原因是各个线程间的数据值没有可视性造成的。而关键字synchronized具有可视性。改进：

```
public class Service {
    private boolean isContinueRun = true;
    public void runMethod() {
        String anything =new String();
        while(isContinueRun == true) {
           synchronized (anything) {
			
		   }
        }
        System.out.println("停下来了");
    }
    public void stopMethod() {
        isContinueRun = false;
    }
}
```
关键字synchronized可以保证在同一时刻，只有一个线程可以执行某一个方法或者某一个代码块

他包含了两个特性，互斥性和可见性，同步synchronized不仅可以解决一个线程看到的对象处于不一致的状态，还可以保证进入同步方法或者同步代码块的每个线程都看到由同一个锁保护之前的修改效果。