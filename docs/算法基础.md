### 一、队列和栈

#### 1.1、栈和队列的基本性质

1. 栈是先进后出的

2. 队列是先进先出的

3. 栈和队列在实现结构上可以有数组和链表两种形式

   ①数组结构实现较容易

   ②用链表结构较复杂，因为牵扯很多指针操作

#### 1.2、栈解构的基本操作

1. pop操作：从栈顶弹出一个元素
2. top或peek操作：只访问栈顶元素而不弹出
3. push操作：从栈顶压入一个元素
4. size操作：返回当前栈的元素个数

#### 1.3、队列的基本操作

与栈操作不同的是，push操作为在队头加入元素。

而pop操作是从队列尾部弹出一个元素。

栈和队列的基本操作，都是时间复杂度为O（1）的操作。

双端队列结构为首尾都可以压入和弹出元素。

优先级队列为根据元素的优先级值，决定元素的弹出顺序。

优先级队列的结构为堆结构，并不是线性结构。

#### 1.4、深度优先遍历和宽度优先遍历

深度优先遍历（DFS）可以用栈实现。

宽度优先遍历（BFS）可以用队列实现。



### 附录一、队列和栈练习题

#### 1.1、可查询最值的栈练习题

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。

解答：<script src="https://gist.github.com/Gugibv/4eee19a5a91b3a8b25d95d8d0ab75268.js"></script>





#### 1.2、双栈队列练习题

编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。

给定一个操作序列**ope**及它的长度**n**，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。

测试样例：

> ```
> [1,2,3,0,4,0],6
> 返回：[1,2]
> ```

#### 1.3、栈的反转练习题

实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。

给定一个整数数组**A**即为给定的栈，同时给定它的大小**n**，请返回逆序后的栈。

测试样例：

> ```
> [4,3,2,1],4
> 返回：[1,2,3,4]
> ```

#### 1.4、双栈排序练习题

请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。

给定一个int[] **numbers**(C++中为vector&ltint>)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。

测试样例：

```
[1,2,3,4,5]
返回：[5,4,3,2,1]
```

#### 1.5、滑动窗口练习题

有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。

给定整形数组**arr**及它的大小**n**，同时给定**w**，请返回res数组。保证**w**小于等于**n**，同时保证数组大小小于等于500。

测试样例：

```
[4,3,5,4,3,3,6,7],8,3
返回：[5,5,5,4,6,7]
```

#### 1.6、数组变树练习题

对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。

给定一个无重复元素的数组**A**和它的大小**n**，请返回一个数组，其中每个元素为原数组中对应位置元素在树中的父亲节点的编号，若为根则值为-1。

测试样例：

```
[3,1,4,2],4
返回：[2,0,-1,2]
```